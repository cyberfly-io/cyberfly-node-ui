import React, { useState, useCallback, useEffect, useRef } from 'react';
import {
  Card,
  Button,
  Space,
  Typography,
  Input,
  Tag,
  message,
  Alert,
  Select,
  Switch,
  Tooltip,
  Badge,
  Drawer,
  Grid,
  notification,
  Descriptions,
  InputNumber,
  Modal,
  Row,
  Col,
  Empty,
  List,
  Divider,
  Form
} from 'antd';
import {
  CodeOutlined,
  LinkOutlined,
  DisconnectOutlined,
  SendOutlined,
  ClearOutlined,
  SyncOutlined,
  ThunderboltOutlined,
  SettingOutlined,
  CopyOutlined,
  ExportOutlined,
  WifiOutlined,
  EyeOutlined,
  NotificationOutlined,
  EditOutlined,
  CheckCircleTwoTone,
  WarningTwoTone
} from '@ant-design/icons';

const { Title, Text } = Typography;
const { Option } = Select;
const { useBreakpoint } = Grid;
const { TextArea } = Input;

/**
 * Updated to match firmware:
 * Service UUID + distinct RX (write) and TX (notify) characteristic UUIDs.
 */
const SERVICE_UUID   = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const RX_CHAR_UUID   = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
const TX_CHAR_UUID   = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';
const DEFAULT_CHUNK_SIZE = 180;       // Firmware requests MTU=180
// Match updated MicroPython firmware (_MAX_RX = 384, fragment timeout 2000ms)
const MAX_JSON_SIZE = 384;
const FRAGMENT_TIMEOUT_MS = 2000;
const DEVICE_NAME_PREFIX = 'CYBERFLY'; // Advertised name starts with CYBERFLY-SETUP

const REQUIRED_FIELDS = ['device_id', 'ssid', 'publicKey'];

const toBLE = (u) => u?.toLowerCase();

const BLEPage = () => {
  // Connection
  const [device, setDevice] = useState(null);
  const [server, setServer] = useState(null);
  const [rxCharacteristic, setRxCharacteristic] = useState(null);
  const [txCharacteristic, setTxCharacteristic] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isScanning, setIsScanning] = useState(false);
  const [isNotifying, setIsNotifying] = useState(false);
  const [connectionStrength, setConnectionStrength] = useState(0);

  // Data IO
  const [jsonInput, setJsonInput] = useState('');
  const [receivedData, setReceivedData] = useState('');
  const [assemblingMessage, setAssemblingMessage] = useState('');
  const assemblingRef = useRef('');

  // Provisioning form
  const [form] = Form.useForm();
  const [autoNetworkId, setAutoNetworkId] = useState('mainnet01');
  const [provisionStatus, setProvisionStatus] = useState(null); // saved | error | null
  const [provisionMsg, setProvisionMsg] = useState('');

  // UI / Preferences
  const [drawerVisible, setDrawerVisible] = useState(false);
  const [jsonModalVisible, setJsonModalVisible] = useState(false);
  const [logLevel, setLogLevel] = useState('all');
  const [autoScroll, setAutoScroll] = useState(true);
  const [notifications, setNotifications] = useState(true);
  const [chunkSize, setChunkSize] = useState(DEFAULT_CHUNK_SIZE);
  const [prettyJson, setPrettyJson] = useState(true);

  // Logs
  const [logs, setLogs] = useState([]);

  // Scan options
  const [scanAll, setScanAll] = useState(true);
  const [namePrefix, setNamePrefix] = useState(DEVICE_NAME_PREFIX);
  const [lastScanError, setLastScanError] = useState(null);

  // Refs
  const logRef = useRef(null);
  const notifyListenerRef = useRef(null);
  const connectingRef = useRef(false);
  const lastFragmentAtRef = useRef(0); // track last fragment timestamp (ms)

  const screens = useBreakpoint();

  // Add log (append chronological)
  const addLog = useCallback(
    (messageText, type = 'info', data = null) => {
      const logEntry = {
        id: crypto.randomUUID?.() || Date.now().toString(),
        ts: new Date().toLocaleTimeString(),
        message: messageText,
        type,
        data
      };
      setLogs((prev) => [...prev, logEntry].slice(-1000));
      if (notifications && ['error', 'success', 'received'].includes(type)) {
        notification[type === 'error' ? 'error' : 'success']({
          message: type === 'error' ? 'BLE Error' : type === 'received' ? 'Data Received' : 'BLE Success',
          description: messageText,
          duration: 3,
          placement: 'topRight'
        });
      }
      if (autoScroll && logRef.current) {
        requestAnimationFrame(() => {
          logRef.current.scrollTop = logRef.current.scrollHeight;
        });
      }
    },
    [notifications, autoScroll]
  );

  // Device JSON handler (status routing)
  const handleDeviceJSON = useCallback((obj) => {
    if (!obj || typeof obj !== 'object') {
      addLog('Device sent non-object JSON', 'warn');
      return;
    }
    const status = obj.status;
    switch (status) {
      case 'ready':
        addLog('Device ready', 'success');
        setProvisionStatus(null);
        setProvisionMsg('Device ready – send configuration.');
        break;
      case 'saved':
        addLog('Configuration saved on device', 'success');
        setProvisionStatus('saved');
        setProvisionMsg('Configuration saved. Device may restart.');
        notification.success({
            message: 'Provisioning Complete',
            description: 'Device reports saved configuration.',
            duration: 4
        });
        break;
      case 'error': {
        const msg = obj.msg || obj.message || 'Device error';
        addLog(`Device error: ${msg}`, 'error');
        if (/bad_json/i.test(msg)) addLog('Firmware parse error: JSON invalid', 'warn');
        if (/missing:/i.test(msg)) addLog('Firmware reports missing required field(s)', 'warn');
        if (/save_failed/i.test(msg)) addLog('Firmware failed to persist configuration', 'warn');
        setProvisionStatus('error');
        setProvisionMsg(msg);
        break;
      }
      default:
        addLog('Device message', 'info', obj);
        if (obj.msg || obj.message) {
          setProvisionMsg(obj.msg || obj.message);
        }
    }
    if (obj.device_id) {
      addLog(`Device ID: ${obj.device_id}`, 'info');
    }
  }, [addLog]);

  // Helper: parse JSON that may be quoted (firmware sometimes wraps JSON as a string)
  const parseMaybeQuotedJSON = useCallback((s) => {
    if (typeof s !== 'string') return null;
    const txt = s.trim();
    try {
      // Fast path: direct parse
      return JSON.parse(txt);
    } catch (e) {
      // If wrapped in quotes, try to unwrap once
      if (txt.startsWith('"') && txt.endsWith('"')) {
        try {
          const inner = JSON.parse(txt);
          if (typeof inner === 'string') {
            try {
              return JSON.parse(inner);
            } catch (_) {
              // inner is string but not JSON; return inner string
              return inner;
            }
          }
        } catch (_) {}
      }
      return null;
    }
  }, []);

  // Simulated connection strength (replace with RSSI if available)
  useEffect(() => {
    if (!isConnected) return;
    const t = setInterval(() => {
      setConnectionStrength(70 + Math.random() * 25);
    }, 3000);
    return () => clearInterval(t);
  }, [isConnected]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      try {
        if (txCharacteristic && notifyListenerRef.current) {
          txCharacteristic.removeEventListener('characteristicvaluechanged', notifyListenerRef.current);
        }
        if (device?.gatt?.connected) device.gatt.disconnect();
      } catch (_) {}
    };
  }, [txCharacteristic, device]);

  const ensureAPI = () => {
    if (!navigator.bluetooth) {
      message.error('Web Bluetooth not supported (Chrome/Edge HTTPS)');
      addLog('Web Bluetooth API not supported', 'error');
      return false;
    }
    return true;
  };

  // Enhanced connection state tracking
  const [connectionState, setConnectionState] = useState('disconnected'); 
  const [connectionAttempts, setConnectionAttempts] = useState(0);

  // Enhanced connection parameters
  const CONNECTION_TIMEOUT = 8000; // Reduced from 15s to 8s
  const SERVICE_DISCOVERY_TIMEOUT = 3000; // Reduced timeout for faster failure detection
  const RECONNECT_ATTEMPTS = 2; // Reduced for faster recovery

  // Add connection health monitoring
  const [lastConnectionCheck, setLastConnectionCheck] = useState(null);
  const connectionHealthRef = useRef(null);
  const [deviceSignalStrength, setDeviceSignalStrength] = useState(null);

  // Monitor connection health periodically
  useEffect(() => {
    if (connectionState === 'ready' && device?.gatt) {
      connectionHealthRef.current = setInterval(() => {
        const isHealthy = device.gatt.connected;
        setLastConnectionCheck(new Date().toLocaleTimeString());
        
        if (!isHealthy) {
          addLog('Connection health check failed - device disconnected', 'warn');
          setConnectionState('disconnected');
          handleDisconnection();
        }
      }, 3000); // Check every 3 seconds for faster detection
      
      return () => {
        if (connectionHealthRef.current) {
          clearInterval(connectionHealthRef.current);
        }
      };
    }
  }, [connectionState, device, addLog]);

  // Replace reconnectGatt with a simpler version
  const reconnectGatt = useCallback(async (dev = device) => {
    if (!dev?.gatt) return null;
    if (dev.gatt.connected) return dev.gatt;
    try {
      addLog('Reconnecting GATT…', 'info');
      const g = await dev.gatt.connect();
      await new Promise(r => setTimeout(r, 300)); // small settle delay
      if (g.connected) {
        addLog('Reconnected', 'success');
        return g;
      }
    } catch (e) {
      addLog(`Reconnect failed: ${e.message}`, 'warn');
    }
    return null;
  }, [device, addLog]);

  // Replace scanAndConnect with simplified guarded version
  const scanAndConnect = async () => {
    if (!ensureAPI()) return;
    if (connectingRef.current) {
      addLog('Connect already in progress', 'warn');
      return;
    }
    connectingRef.current = true;
    setConnectionState('connecting');
    try {
      setConnectionAttempts(c => c + 1);
      setProvisionStatus(null);
      setProvisionMsg('');
      setLastScanError(null);
      setIsScanning(true);

      // Fast path: existing device reconnect
      if (device && !device.gatt.connected) {
        const g = await reconnectGatt(device);
        if (g?.connected) {
          setServer(g);
          setIsConnected(true);
          await setupProvisioner(g);
          return;
        }
      }

      // Fresh selection
      const options = scanAll
        ? { acceptAllDevices: true, optionalServices: [SERVICE_UUID] }
        : {
            // include both prefix and explicit common advertised name
            filters: [
              ...(namePrefix?.trim() ? [{ namePrefix: namePrefix.trim() }] : []),
              ...(namePrefix?.trim() ? [{ name: (namePrefix.trim() + '-SETUP') }] : [])
            ],
            optionalServices: [SERVICE_UUID]
          };

      addLog(`requestDevice ${JSON.stringify(options)}`);
      const selected = await navigator.bluetooth.requestDevice(options);
      if (!selected) {
        addLog('No device selected', 'warn');
        return;
      }
      setDevice(selected);
      selected.addEventListener('gattserverdisconnected', () => {
        addLog('Disconnected (event)', 'warn');
        handleDisconnection();
      });

      addLog('Connecting GATT…', 'info');
      const gatt = await selected.gatt.connect();
      await new Promise(r => setTimeout(r, 400)); // settle
      if (!gatt.connected) throw new Error('GATT not connected after connect()');

      setServer(gatt);
      setIsConnected(true);
      setConnectionState('connected');
      addLog('GATT connected', 'success');

      await setupProvisioner(gatt);
    } catch (e) {
      setLastScanError(e.message);
      addLog(`Connection error: ${e.message}`, 'error');
      handleDisconnection();
    } finally {
      setIsScanning(false);
      connectingRef.current = false;
    }
  };

  // Replace setupProvisioner with lean version
  const setupProvisioner = async (gatt) => {
    if (!gatt) return;
    if (!gatt.connected) {
      addLog('setupProvisioner: GATT not connected, abort', 'error');
      return;
    }
    setConnectionState('discovering');
    try {
      const safeGetService = async () => {
        try {
          return await gatt.getPrimaryService(SERVICE_UUID);
        } catch (e) {
          if (/disconnected/i.test(e.message)) {
            addLog('Service discovery: disconnected, retrying once', 'warn');
            const rg = await reconnectGatt(device);
              if (rg?.connected) {
                await new Promise(r => setTimeout(r, 300));
                return await rg.getPrimaryService(SERVICE_UUID);
              }
          }
          throw e;
        }
      };

      addLog('Discovering service…', 'info');
      const service = await safeGetService();
      if (!service) throw new Error('Service not found');

      const chars = await service.getCharacteristics();
      addLog(`Chars found: ${chars.length}`, 'info');

      const rx = chars.find(c => c.uuid.toLowerCase() === RX_CHAR_UUID.toLowerCase()) ||
                 chars.find(c => c.properties.write || c.properties.writeWithoutResponse);
      const tx = chars.find(c => c.uuid.toLowerCase() === TX_CHAR_UUID.toLowerCase()) ||
                 chars.find(c => c.properties.notify);

      if (!rx) throw new Error('RX characteristic missing');
      if (!tx) throw new Error('TX characteristic missing');

      setRxCharacteristic(rx);
      setTxCharacteristic(tx);
      addLog(`RX=${rx.uuid} TX=${tx.uuid}`, 'success');

      // Notifications
      if (notifyListenerRef.current) {
        try { tx.removeEventListener('characteristicvaluechanged', notifyListenerRef.current); } catch {}
      }
      const onNotify = (evt) => {
        try {
          const text = new TextDecoder().decode(evt.target.value);
          addLog(`← ${text}`, 'received', text);
          setReceivedData(prev => prev + text);

          const now = Date.now();
          // Drop stale partial buffer if timeout exceeded (firmware uses _FRAGMENT_TIMEOUT_MS)
          if (lastFragmentAtRef.current && (now - lastFragmentAtRef.current) > FRAGMENT_TIMEOUT_MS) {
            assemblingRef.current = '';
          }
          lastFragmentAtRef.current = now;

          // If fragment begins a new JSON object, reset (mirrors firmware behavior)
          if (text.charCodeAt(0) === 0x7B) { // '{'
            assemblingRef.current = '';
          }

          assemblingRef.current += text;
            // Keep only most recent MAX_JSON_SIZE bytes
          if (assemblingRef.current.length > MAX_JSON_SIZE) {
            assemblingRef.current = assemblingRef.current.slice(-MAX_JSON_SIZE);
          }

          const candidate = assemblingRef.current.trim();
          if (candidate) {
            const parsed = parseMaybeQuotedJSON(candidate);
            if (parsed !== null) {
              if (typeof parsed === 'string') {
                // Double-wrapped or plain text
                try {
                  const inner = JSON.parse(parsed);
                  handleDeviceJSON(inner);
                } catch {
                  setProvisionMsg(parsed);
                  addLog(`Device text: ${parsed}`, 'info');
                }
              } else {
                handleDeviceJSON(parsed);
              }
              assemblingRef.current = '';
              lastFragmentAtRef.current = 0;
              setAssemblingMessage('');
              return;
            }
          }
          // Not parseable yet
          setAssemblingMessage(assemblingRef.current);
        } catch (e) {
          addLog(`Notify parse error: ${e.message}`, 'warn');
        }
      };
      notifyListenerRef.current = onNotify;
      await tx.startNotifications();
      tx.addEventListener('characteristicvaluechanged', onNotify);
      setIsNotifying(true);
      addLog('Notifications started', 'success');

      setConnectionState('ready');
    } catch (e) {
      addLog(`Setup failed: ${e.message}`, 'error');
      message.error(`Setup failed: ${e.message}`);
      handleDisconnection();
    }
  };

  // Enhanced disconnect handling
  const handleDisconnection = () => {
    try {
      if (connectionHealthRef.current) {
        clearInterval(connectionHealthRef.current);
        connectionHealthRef.current = null;
      }
      
      if (txCharacteristic && notifyListenerRef.current) {
        txCharacteristic.removeEventListener('characteristicvaluechanged', notifyListenerRef.current);
      }
    } catch (_) {}
    
    setServer(null);
    setRxCharacteristic(null);
    setTxCharacteristic(null);
    setIsConnected(false);
    setIsNotifying(false);
    setConnectionState('disconnected');
    setDeviceSignalStrength(null);
    assemblingRef.current = '';
    setAssemblingMessage('');
  };

  // Enhanced status display with timeout info
  const statusTag = (() => {
    switch (connectionState) {
      case 'connecting':
        return (
          <Space size={2}>
            <Tag color="orange" icon={<SyncOutlined spin />}>Connecting…</Tag>
            <Text type="secondary" style={{ fontSize: 11 }}>
              #{connectionAttempts} ({CONNECTION_TIMEOUT/1000}s timeout)
            </Text>
          </Space>
        );
      case 'connected':
        return <Tag color="blue" icon={<LinkOutlined />}>Connected</Tag>;
      case 'discovering':
        return (
          <Space size={2}>
            <Tag color="blue" icon={<SyncOutlined spin />}>Discovering…</Tag>
            <Text type="secondary" style={{ fontSize: 11 }}>
              ({SERVICE_DISCOVERY_TIMEOUT/1000}s timeout)
            </Text>
          </Space>
        );
      case 'ready':
        return (
          <Space size={4}>
            <Tag color="green" icon={<LinkOutlined />}>Ready</Tag>
            {isNotifying && <Tag color="blue" icon={<NotificationOutlined />}>Listening</Tag>}
            {lastConnectionCheck && (
              <Tooltip title={`Last health check: ${lastConnectionCheck}`}>
                <Tag color="green">
                  <WifiOutlined /> {connectionStrength.toFixed(0)}%
                </Tag>
              </Tooltip>
            )}
          </Space>
        );
      default:
        return <Tag color="red" icon={<DisconnectOutlined />}>Disconnected</Tag>;
    }
  })();

  // Add timeout information to scan error display
  const renderScanError = () => {
    if (!lastScanError) return null;
    
    const isTimeout = lastScanError.includes('timeout');
    
    return (
      <Alert
        type="warning"
        showIcon
        message={isTimeout ? "Connection Timeout" : "Scan Issue"}
        description={
          <Space direction="vertical" size="small">
            <Text>{lastScanError}</Text>
            {isTimeout && (
              <div>
                <Text strong>Quick fixes:</Text>
                <ul style={{ margin: '4px 0', paddingLeft: 20 }}>
                  <li>Move device closer (within 1 meter)</li>
                  <li>Ensure device is actively advertising</li>
                  <li>Check device battery level</li>
                  <li>Try disconnecting from other Bluetooth apps</li>
                  <li>Power cycle the device</li>
                </ul>
              </div>
            )}
            <Text type="secondary">
              Current timeouts: Connection {CONNECTION_TIMEOUT/1000}s, Discovery {SERVICE_DISCOVERY_TIMEOUT/1000}s
            </Text>
          </Space>
        }
      />
    );
  };

  const disconnect = () => {
    try {
      if (device?.gatt?.connected) {
        device.gatt.disconnect();
        addLog('Manual disconnect', 'info');
        message.info('Disconnected');
      }
    } catch (e) {
      addLog(`Disconnect error: ${e.message}`, 'error');
    } finally {
      connectingRef.current = false;
      handleDisconnection();
    }
  };

  // NEW: Forget device (clear reference so chooser re‑prompts)
  const forgetDevice = () => {
    disconnect();
    setDevice(null);
    addLog('Forgot device reference. Ready to pair a new device.', 'info');
    message.success('Device forgotten – click Connect to pick a new one.');
  };

  const validateAndFormatJSON = (raw) => {
    const parsed = JSON.parse(raw);
    return prettyJson ? JSON.stringify(parsed, null, 2) : JSON.stringify(parsed);
  };

  const sendJSONRaw = async (payload) => {
    if (!rxCharacteristic) {
      message.warning('RX characteristic not ready');
      return false;
    }
    try {
      const bytes = new TextEncoder().encode(payload);
      if (bytes.length > MAX_JSON_SIZE) {
        message.error(`JSON exceeds device max ${MAX_JSON_SIZE} bytes (_MAX_RX)`);
        return false;
      }
      if (bytes.length <= chunkSize) {
        await rxCharacteristic.writeValue(bytes);
        addLog(`Sent (${bytes.length} bytes)`, 'success');
      } else {
        const total = Math.ceil(bytes.length / chunkSize);
        addLog(`Sending ${bytes.length} bytes in ${total} chunks`);
        for (let i = 0; i < total; i++) {
          const slice = bytes.slice(i * chunkSize, i * chunkSize + chunkSize);
          await rxCharacteristic.writeValue(slice);
          addLog(`Chunk ${i + 1}/${total} (${slice.length} bytes)`);
          await new Promise((r) => setTimeout(r, 8));
        }
        addLog('All chunks sent', 'success');
      }
      return true;
    } catch (e) {
      addLog(`Send failed: ${e.message}`, 'error');
      message.error('Send failed');
      return false;
    }
  };

  const sendJSON = async (override = null) => {
    let payload = override ?? jsonInput;
    if (!payload.trim()) {
      message.warning('Empty JSON');
      return;
    }
    try {
      payload = validateAndFormatJSON(payload);
    } catch (e) {
      addLog(`Invalid JSON: ${e.message}`, 'error');
      message.error('Invalid JSON');
      return;
    }
    const ok = await sendJSONRaw(payload);
    if (ok && !override) setJsonInput('');
  };

  const submitProvision = async () => {
    try {
      const values = await form.validateFields();
      const cfg = {
        device_id: values.device_id.trim(),
        ssid: values.ssid.trim(),
        wifi_password: values.wifi_password || '',
        network_id: values.network_id || autoNetworkId,
        key_pair: {
          publicKey: values.publicKey.trim(),
          secretKey: values.secretKey || ''
        }
      };
      // Validate required
      const missing = REQUIRED_FIELDS.filter((f) => {
        if (f === 'publicKey') return !cfg.key_pair.publicKey;
        return !cfg[f];
      });
      if (missing.length) {
        message.error('Missing: ' + missing.join(', '));
        return;
      }
      const payload = prettyJson ? JSON.stringify(cfg, null, 2) : JSON.stringify(cfg);
      addLog('Sending configuration JSON', 'info');
      const ok = await sendJSONRaw(payload);
      if (ok) {
        setProvisionStatus(null);
        setProvisionMsg('Awaiting device response...');
      }
    } catch (e) {
      // validation error
    }
  };

  const formatJSONInput = () => {
    try {
      setJsonInput(validateAndFormatJSON(jsonInput));
      message.success('Formatted');
    } catch {
      message.error('Invalid JSON');
    }
  };

  const clearLogs = () => {
    setLogs([]);
    message.success('Logs cleared');
  };

  const clearReceived = () => {
    setReceivedData('');
    assemblingRef.current = '';
    setAssemblingMessage('');
    message.success('Cleared received');
  };

  const exportLogs = () => {
    const data = logs.map((l) => `[${l.ts}] ${l.type.toUpperCase()}: ${l.message}`).join('\n');
    const blob = new Blob([data], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ble-logs-${new Date().toISOString().slice(0, 10)}.txt`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    message.success('Logs exported');
  };

  const copyToClipboard = (text) => {
    navigator.clipboard
      .writeText(text)
      .then(() => message.success('Copied'))
      .catch(() => message.error('Copy failed'));
  };

  const filteredLogs = logLevel === 'all' ? logs : logs.filter((l) => l.type === logLevel);

  return (
    <PageContainer
      title="BLE Device Provisioning"
      subTitle="Configure Cyberfly IoT devices over Bluetooth Low Energy"
      header={{
        style: { padding: '16px 0' }
      }}
      extra={[
        <Button
          key="settings"
          icon={<SettingOutlined />}
          onClick={() => setDrawerVisible(true)}
        >
          Settings
        </Button>
      ]}
    >
      <Space direction="vertical" size="large" style={{ width: '100%' }}>
        {/* Connection Status Overview */}
        <Row gutter={[24, 24]}>
          <Col xs={24} sm={12} lg={6}>
            <Card bordered={false} style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}>
              <Statistic
                title="Connection Status"
                value={connectionState === 'ready' ? 'Connected' : connectionState}
                valueStyle={{
                  color: connectionState === 'ready' ? '#52c41a' :
                         connectionState === 'connecting' ? '#fa8c16' : '#ff4d4f'
                }}
                prefix={<WifiOutlined />}
              />
            </Card>
          </Col>
          <Col xs={24} sm={12} lg={6}>
            <Card bordered={false} style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}>
              <Statistic
                title="Signal Strength"
                value={connectionStrength.toFixed(0)}
                suffix="%"
                prefix={<ThunderboltOutlined />}
                valueStyle={{ color: connectionStrength > 70 ? '#52c41a' : '#fa8c16' }}
              />
            </Card>
          </Col>
          <Col xs={24} sm={12} lg={6}>
            <Card bordered={false} style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}>
              <Statistic
                title="Connection Attempts"
                value={connectionAttempts}
                prefix={<SyncOutlined />}
              />
            </Card>
          </Col>
          <Col xs={24} sm={12} lg={6}>
            <Card bordered={false} style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}>
              <Statistic
                title="Device Status"
                value={provisionStatus === 'saved' ? 'Provisioned' : 'Ready'}
                valueStyle={{ color: provisionStatus === 'saved' ? '#52c41a' : '#1890ff' }}
                prefix={<CheckCircleTwoTone twoToneColor={provisionStatus === 'saved' ? '#52c41a' : '#1890ff'} />}
              />
            </Card>
          </Col>
        </Row>

        {/* Connection Management */}
        <Card
          title={
            <Space>
              <LinkOutlined />
              <span>Device Connection</span>
            </Space>
          }
          bordered={false}
          style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}
          extra={statusTag}
        >
          <Space direction="vertical" size="middle" style={{ width: '100%' }}>
            <Row gutter={[16, 16]}>
              <Col xs={24} sm={12}>
                <Space>
                  <Text strong>Scan Mode:</Text>
                  <Switch
                    checked={scanAll}
                    onChange={setScanAll}
                    checkedChildren="All Devices"
                    unCheckedChildren="Filtered"
                  />
                </Space>
              </Col>
              {!scanAll && (
                <Col xs={24} sm={12}>
                  <Space>
                    <Text strong>Name Prefix:</Text>
                    <Input
                      placeholder="CYBERFLY"
                      value={namePrefix}
                      onChange={(e) => setNamePrefix(e.target.value)}
                      allowClear
                      style={{ width: 140 }}
                    />
                  </Space>
                </Col>
              )}
            </Row>

            <Space>
              <Button
                type="primary"
                icon={<SyncOutlined spin={isScanning} />}
                disabled={isScanning || isConnected}
                loading={isScanning}
                onClick={scanAndConnect}
                size="large"
              >
                {isConnected ? 'Connected' : 'Connect Device'}
              </Button>

              {isConnected && (
                <>
                  <Button
                    danger
                    icon={<DisconnectOutlined />}
                    onClick={disconnect}
                    size="large"
                  >
                    Disconnect
                  </Button>
                  <Button
                    icon={<WifiOutlined />}
                    onClick={forgetDevice}
                    size="large"
                  >
                    Forget Device
                  </Button>
                </>
              )}
            </Space>

            {renderScanError()}
          </Space>
        </Card>

        {/* Provisioning Configuration */}
        <Card
          title={
            <Space>
              <CodeOutlined />
              <span>Device Configuration</span>
            </Space>
          }
          bordered={false}
          style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}
          extra={
            <Space>
              <Button
                icon={<EditOutlined />}
                onClick={() => setJsonModalVisible(true)}
              >
                Templates
              </Button>
              <Button
                type="primary"
                icon={<SendOutlined />}
                onClick={submitProvision}
                disabled={!isConnected || !txCharacteristic}
                loading={loading}
              >
                Send Configuration
              </Button>
            </Space>
          }
        >
          <Form
            form={form}
            layout="vertical"
            size="middle"
          >
            <Row gutter={[24, 16]}>
              <Col xs={24} sm={12} lg={8}>
                <Form.Item
                  label="Device ID"
                  name="device_id"
                  rules={[{ required: true, message: 'Device ID is required' }]}
                >
                  <Input placeholder="Enter device identifier" />
                </Form.Item>
              </Col>
              <Col xs={24} sm={12} lg={8}>
                <Form.Item
                  label="WiFi SSID"
                  name="ssid"
                  rules={[{ required: true, message: 'WiFi SSID is required' }]}
                >
                  <Input placeholder="WiFi network name" />
                </Form.Item>
              </Col>
              <Col xs={24} sm={12} lg={8}>
                <Form.Item
                  label="WiFi Password"
                  name="wifi_password"
                >
                  <Input.Password placeholder="WiFi password (optional)" />
                </Form.Item>
              </Col>
              <Col xs={24} sm={12} lg={8}>
                <Form.Item
                  label="Network ID"
                  name="network_id"
                >
                  <Select placeholder="Select network">
                    <Option value="mainnet01">Mainnet 01</Option>
                    <Option value="testnet01">Testnet 01</Option>
                    <Option value="devnet01">Devnet 01</Option>
                  </Select>
                </Form.Item>
              </Col>
              <Col xs={24} sm={12} lg={8}>
                <Form.Item
                  label="Public Key"
                  name="publicKey"
                  rules={[{ required: true, message: 'Public key is required' }]}
                >
                  <Input placeholder="Device public key" />
                </Form.Item>
              </Col>
              <Col xs={24} sm={12} lg={8}>
                <Form.Item
                  label="Secret Key"
                  name="secretKey"
                >
                  <Input.Password placeholder="Device secret key (optional)" />
                </Form.Item>
              </Col>
            </Row>
          </Form>

          {provisionMsg && (
            <Alert
              message="Device Response"
              description={provisionMsg}
              type={provisionStatus === 'saved' ? 'success' : provisionStatus === 'error' ? 'error' : 'info'}
              showIcon
              style={{ marginTop: 16 }}
            />
          )}
        </Card>

        {/* Communication Logs */}
        <Card
          title={
            <Space>
              <NotificationOutlined />
              <span>Communication Logs</span>
              <Badge count={filteredLogs.length} style={{ backgroundColor: '#1890ff' }} />
            </Space>
          }
          bordered={false}
          style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}
          extra={
            <Space>
              <Select
                value={logLevel}
                onChange={setLogLevel}
                style={{ width: 100 }}
                size="small"
              >
                <Option value="all">All</Option>
                <Option value="info">Info</Option>
                <Option value="success">Success</Option>
                <Option value="warn">Warning</Option>
                <Option value="error">Error</Option>
              </Select>
              <Button
                icon={<ClearOutlined />}
                onClick={clearLogs}
                size="small"
              >
                Clear
              </Button>
              <Button
                icon={<ExportOutlined />}
                onClick={exportLogs}
                size="small"
              >
                Export
              </Button>
            </Space>
          }
        >
          <div
            ref={logRef}
            style={{
              height: 300,
              overflow: 'auto',
              background: '#f5f5f5',
              borderRadius: 6,
              padding: 12,
              fontFamily: 'monospace',
              fontSize: 12
            }}
          >
            {filteredLogs.length === 0 ? (
              <Text type="secondary" style={{ textAlign: 'center', display: 'block', padding: '40px' }}>
                No logs yet. Connect to a device to start seeing communication logs.
              </Text>
            ) : (
              filteredLogs.map((log, index) => (
                <div
                  key={index}
                  style={{
                    marginBottom: 4,
                    color: {
                      info: '#1890ff',
                      success: '#52c41a',
                      warn: '#fa8c16',
                      error: '#ff4d4f'
                    }[log.type] || '#666'
                  }}
                >
                  <Text style={{ fontSize: 11, color: '#999', marginRight: 8 }}>
                    {log.ts}
                  </Text>
                  <Text style={{ fontWeight: 500, marginRight: 8 }}>
                    [{log.type.toUpperCase()}]
                  </Text>
                  <Text>{log.message}</Text>
                </div>
              ))
            )}
          </div>
        </Card>

        {/* Raw JSON Communication */}
        <Card
          title={
            <Space>
              <CodeOutlined />
              <span>Raw JSON Communication</span>
            </Space>
          }
          bordered={false}
          style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}
        >
          <Space direction="vertical" size="middle" style={{ width: '100%' }}>
            <div>
              <Text strong style={{ display: 'block', marginBottom: 8 }}>Send Custom JSON</Text>
              <TextArea
                value={jsonInput}
                onChange={(e) => setJsonInput(e.target.value)}
                placeholder="Enter JSON to send to device..."
                rows={6}
                style={{ fontFamily: 'monospace' }}
              />
              <Space style={{ marginTop: 8 }}>
                <Button
                  icon={<SendOutlined />}
                  onClick={() => sendJSON()}
                  disabled={!isConnected || !rxCharacteristic}
                  type="primary"
                >
                  Send JSON
                </Button>
                <Button
                  icon={<CodeOutlined />}
                  onClick={formatJSONInput}
                >
                  Format JSON
                </Button>
                <Button
                  icon={<ClearOutlined />}
                  onClick={() => setJsonInput('')}
                >
                  Clear
                </Button>
              </Space>
            </div>

            <Divider />

            <div>
              <Text strong style={{ display: 'block', marginBottom: 8 }}>Received Data</Text>
              <TextArea
                value={receivedData}
                readOnly
                rows={4}
                style={{ fontFamily: 'monospace', background: '#f5f5f5' }}
                placeholder="Data received from device will appear here..."
              />
              <Space style={{ marginTop: 8 }}>
                <Button
                  icon={<CopyOutlined />}
                  onClick={() => copyToClipboard(receivedData)}
                  disabled={!receivedData}
                >
                  Copy
                </Button>
                <Button
                  icon={<ClearOutlined />}
                  onClick={clearReceived}
                >
                  Clear
                </Button>
              </Space>
            </div>

            {assemblingMessage && (
              <Alert
                message="Assembling Message"
                description={`Currently assembling: ${assemblingMessage}`}
                type="info"
                showIcon
                style={{ marginTop: 16 }}
              />
            )}
          </Space>
        </Card>

        {/* Information Section */}
        <Card
          title="Device Information"
          bordered={false}
          style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}
          size="small"
        >
          <Space direction="vertical" size="small">
            <Text strong>Firmware Expectations</Text>
            <Text>
              Send JSON with device_id, ssid, wifi_password, network_id, key_pair {'{'} publicKey, secretKey {'}'}.
              Device replies with status saved/error.
            </Text>
            <Text type="secondary">
              Max payload {MAX_JSON_SIZE}B. Device replies with {'{'}status:'ready'|'saved'|'error', msg?{'}'} (msg may be bad_json, missing:..., save_failed).
            </Text>
          </Space>
        </Card>

        {/* Templates Modal */}
        <Modal
          title="Configuration Templates"
          open={jsonModalVisible}
          onCancel={() => setJsonModalVisible(false)}
          footer={null}
          width={600}
        >
          <Space direction="vertical" style={{ width: '100%' }} size="middle">
            {[
              {
                name: 'Minimal Example',
                tpl: {
                  device_id: 'DEVICE001',
                  ssid: 'MyWiFi',
                  wifi_password: '',
                  network_id: autoNetworkId,
                  key_pair: { publicKey: 'PUBKEY', secretKey: '' }
                }
              },
              {
                name: 'Full Example',
                tpl: {
                  device_id: 'DEVICE123',
                  ssid: 'MyWifi',
                  wifi_password: 'password',
                  network_id: 'mainnet01',
                  key_pair: {
                    publicKey: 'PUBKEY',
                    secretKey: 'SECRET'
                  }
                }
              }
            ].map(({ name, tpl }) => (
              <Card key={name} size="small" style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.1)' }}>
                <Space direction="vertical" style={{ width: '100%' }} size="small">
                  <Space style={{ width: '100%', justifyContent: 'space-between' }}>
                    <Text strong>{name}</Text>
                    <Space>
                      <Button size="small" onClick={() => copyToClipboard(JSON.stringify(tpl, null, 2))}>
                        Copy
                      </Button>
                      <Button
                        size="small"
                        type="primary"
                        onClick={() => {
                          form.setFieldsValue({
                            device_id: tpl.device_id,
                            ssid: tpl.ssid,
                            wifi_password: tpl.wifi_password,
                            network_id: tpl.network_id,
                            publicKey: tpl.key_pair.publicKey,
                            secretKey: tpl.key_pair.secretKey
                          });
                          setJsonModalVisible(false);
                        }}
                      >
                        Use
                      </Button>
                    </Space>
                  </Space>
                  <pre
                    style={{
                      background: '#f5f5f5',
                      margin: 0,
                      padding: 12,
                      fontSize: 12,
                      borderRadius: 4,
                      maxHeight: 200,
                      overflow: 'auto'
                    }}
                  >
                    {JSON.stringify(tpl, null, 2)}
                  </pre>
                </Space>
              </Card>
            ))}
          </Space>
        </Modal>

        {/* Settings Drawer */}
        <Drawer
          title="BLE Settings"
          placement="right"
          open={drawerVisible}
          onClose={() => setDrawerVisible(false)}
          width={screens.xs ? '100%' : 380}
        >
          <Space direction="vertical" style={{ width: '100%' }} size="large">
            <Card title="Communication Settings" size="small">
              <Space direction="vertical" style={{ width: '100%' }} size="middle">
                <div>
                  <Text strong>Chunk Size</Text>
                  <InputNumber
                    min={20}
                    max={512}
                    style={{ width: '100%', marginTop: 8 }}
                    value={chunkSize}
                    onChange={(v) => setChunkSize(v || DEFAULT_CHUNK_SIZE)}
                    addonAfter="bytes"
                  />
                  <Text type="secondary" style={{ display: 'block', marginTop: 4, fontSize: 12 }}>
                    Payload split threshold (device buffer max {MAX_JSON_SIZE}B, MTU ~180B).
                  </Text>
                </div>

                <div>
                  <Text strong>JSON Formatting</Text>
                  <div style={{ marginTop: 8 }}>
                    <Switch
                      checked={prettyJson}
                      onChange={setPrettyJson}
                      checkedChildren="Pretty"
                      unCheckedChildren="Minified"
                    />
                    <Text type="secondary" style={{ marginLeft: 8 }}>Outgoing JSON formatting</Text>
                  </div>
                </div>
              </Space>
            </Card>

            <Card title="Interface Settings" size="small">
              <Space direction="vertical" style={{ width: '100%' }} size="middle">
                <div>
                  <Text strong>Notifications</Text>
                  <div style={{ marginTop: 8 }}>
                    <Switch
                      checked={notifications}
                      onChange={setNotifications}
                      checkedChildren="On"
                      unCheckedChildren="Off"
                    />
                    <Text type="secondary" style={{ marginLeft: 8 }}>Desktop popups</Text>
                  </div>
                </div>

                <div>
                  <Text strong>Auto Scroll Logs</Text>
                  <div style={{ marginTop: 8 }}>
                    <Switch
                      checked={autoScroll}
                      onChange={setAutoScroll}
                      checkedChildren="On"
                      unCheckedChildren="Off"
                    />
                  </div>
                </div>
              </Space>
            </Card>

            <Card title="Device Information" size="small">
              <Descriptions size="small" column={1}>
                <Descriptions.Item label="Service UUID">
                  <Text code copyable>{SERVICE_UUID}</Text>
                </Descriptions.Item>
                <Descriptions.Item label="RX Characteristic (Write)">
                  <Text code copyable>{RX_CHAR_UUID}</Text>
                </Descriptions.Item>
                <Descriptions.Item label="TX Characteristic (Notify)">
                  <Text code copyable>{TX_CHAR_UUID}</Text>
                </Descriptions.Item>
                <Descriptions.Item label="Max JSON Size">
                  {MAX_JSON_SIZE} bytes
                </Descriptions.Item>
                <Descriptions.Item label="Fragment Timeout">
                  {FRAGMENT_TIMEOUT_MS}ms
                </Descriptions.Item>
              </Descriptions>
            </Card>
          </Space>
        </Drawer>
      </Space>
    </PageContainer>
  );
};
              </Form.Item>
              <Form.Item>
                <Button
                  danger
                  icon={<DisconnectOutlined />}
                  disabled={!isConnected}
                  onClick={disconnect}
                >
                  Disconnect
                </Button>
              </Form.Item>
              <Form.Item>
                <Button
                  onClick={forgetDevice}
                  disabled={!device}
                >
                  Forget Device
                </Button>
              </Form.Item>
            </Form>

            {lastScanError && (
              <Alert
                type="warning"
                showIcon
                message="Scan Issue"
                description={
                  <span>
                    {lastScanError}. Try broad scan, ensure HTTPS, reset device, or clear permissions (chrome://bluetooth-internals).
                  </span>
                }
              />
            )}

            {device && (
              <Descriptions size="small" column={screens.xs ? 1 : 2} style={{ marginTop: 8 }}>
                <Descriptions.Item label="Device">
                  <Text strong>{device.name || 'Device'}</Text>
                </Descriptions.Item>
                <Descriptions.Item label="Service UUID">
                  <Text code>{SERVICE_UUID}</Text>
                </Descriptions.Item>
                <Descriptions.Item label="RX">
                  <Tag color={rxCharacteristic ? 'green' : 'red'}>
                    {rxCharacteristic ? 'Ready' : 'Missing'}
                  </Tag>
                </Descriptions.Item>
                <Descriptions.Item label="TX">
                  <Tag color={isNotifying ? 'green' : 'red'}>{isNotifying ? 'Notify' : 'Off'}</Tag>
                </Descriptions.Item>
              </Descriptions>
            )}

            {provisionStatus === 'saved' && (
              <Alert
                type="success"
                showIcon
                icon={<CheckCircleTwoTone twoToneColor="#52c41a" />}
                message="Provisioned"
                description={provisionMsg}
              />
            )}
            {provisionStatus === 'error' && (
              <Alert
                type="error"
                showIcon
                icon={<WarningTwoTone twoToneColor="#ff4d4f" />}
                message="Device Error"
                description={provisionMsg}
              />
            )}
          </Space>
        </Card>

        <Row gutter={[16, 16]}>
          <Col xs={24} lg={14}>
            <Card
              title="Provisioning Form"
              size="small"
              extra={
                <Space>
                  <Switch
                    size="small"
                    checked={prettyJson}
                    onChange={setPrettyJson}
                    checkedChildren="Pretty"
                    unCheckedChildren="Min"
                  />
                  <Text type="secondary">JSON</Text>
                </Space>
              }
            >
              <Form
                layout="vertical"
                form={form}
                initialValues={{
                  network_id: autoNetworkId
                }}
                disabled={!rxCharacteristic || provisionStatus === 'saved'}
              >
                <Row gutter={12}>
                  <Col span={12}>
                    <Form.Item
                      label="Device ID"
                      name="device_id"
                      rules={[{ required: true, message: 'Required' }]}
                    >
                      <Input placeholder="Device unique id" allowClear />
                    </Form.Item>
                  </Col>
                  <Col span={12}>
                    <Form.Item label="Network ID" name="network_id">
                      <Input
                        placeholder="mainnet01"
                        onChange={(e) => setAutoNetworkId(e.target.value)}
                        allowClear
                      />
                    </Form.Item>
                  </Col>
                </Row>
                <Row gutter={12}>
                  <Col span={12}>
                    <Form.Item
                      label="SSID"
                      name="ssid"
                      rules={[{ required: true, message: 'Required' }]}
                    >
                      <Input placeholder="WiFi SSID" allowClear />
                    </Form.Item>
                  </Col>
                  <Col span={12}>
                    <Form.Item label="WiFi Password" name="wifi_password">
                      <Input.Password placeholder="WiFi password" />
                    </Form.Item>
                  </Col>
                </Row>
                <Form.Item
                  label="Public Key"
                  name="publicKey"
                  rules={[{ required: true, message: 'Required' }]}
                >
                  <Input.TextArea
                    rows={2}
                    placeholder="Account public key"
                    style={{ fontFamily: 'monospace' }}
                  />
                </Form.Item>
                <Form.Item label="Secret Key" name="secretKey">
                  <Input.TextArea
                    rows={2}
                    placeholder="Optional secret key"
                    style={{ fontFamily: 'monospace' }}
                  />
                </Form.Item>
                <Space wrap>
                  <Button
                    type="primary"
                    icon={<SendOutlined />}
                    disabled={!rxCharacteristic || provisionStatus === 'saved'}
                    onClick={submitProvision}
                  >
                    Send Config
                  </Button>
                  <Button
                    onClick={() => {
                      form.resetFields();
                      setProvisionStatus(null);
                      setProvisionMsg('');
                    }}
                    disabled={provisionStatus === 'saved'}
                  >
                    Reset
                  </Button>
                </Space>
              </Form>
              <Divider style={{ margin: '16px 0' }} />
              <Alert
                type="info"
                showIcon
                message="Firmware Expectations"
                description="Send JSON: device_id, ssid, wifi_password, network_id, key_pair { publicKey, secretKey }. Max payload 384B. Device replies with {status:'ready'|'saved'|'error', msg?} (msg may be bad_json, missing:..., save_failed)."
              />
            </Card>
          </Col>

          <Col xs={24} lg={10}>
            <Card
              title="Raw JSON Sender"
              size="small"
              extra={
                <Space>
                  <Button size="small" icon={<EditOutlined />} onClick={() => setJsonModalVisible(true)}>
                    Templates
                  </Button>
                  <Button size="small" onClick={formatJSONInput}>
                    Format
                  </Button>
                </Space>
              }
            >
              <Space direction="vertical" style={{ width: '100%' }} size="middle">
                <TextArea
                  rows={6}
                  value={jsonInput}
                  placeholder='{"device_id":"...","ssid":"..."}'
                  disabled={!rxCharacteristic}
                  onChange={(e) => setJsonInput(e.target.value)}
                  style={{ fontFamily: 'monospace' }}
                />
                <Space wrap>
                  <Button
                    type="primary"
                    icon={<SendOutlined />}
                    disabled={!rxCharacteristic || !jsonInput.trim()}
                    onClick={() => sendJSON()}
                  >
                    Send JSON
                  </Button>
                  <Text type="secondary">Chunk size: {chunkSize}B / Max {MAX_JSON_SIZE}B</Text>
                </Space>
              </Space>
            </Card>

            <Card
              title="Received Data"
              size="small"
              style={{ marginTop: 16 }}
              extra={
                <Space>
                  <Badge count={receivedData.length} overflowCount={9999}>
                    <Tag style={{ margin: 0 }}>Bytes</Tag>
                  </Badge>
                  <Button size="small" onClick={clearReceived}>
                    Clear
                  </Button>
                </Space>
              }
            >
              <Space direction="vertical" style={{ width: '100%' }} size="small">
                <TextArea
                  rows={6}
                  value={receivedData}
                  readOnly
                  placeholder="Device notifications / status"
                  style={{ fontFamily: 'monospace', fontSize: 12 }}
                />
                {receivedData && (
                  <Button
                    size="small"
                    icon={<CopyOutlined />}
                    onClick={() => copyToClipboard(receivedData)}
                  >
                    Copy
                  </Button>
                )}
                {assemblingMessage && (
                  <Alert
                    type="info"
                    message="Assembling JSON…"
                    description={`${assemblingMessage.length} bytes buffered`}
                    showIcon
                  />
                )}
              </Space>
            </Card>
          </Col>
        </Row>

        <Card
          title="Activity Logs"
          size="small"
          extra={
            <Space>
              <Select
                size="small"
                value={logLevel}
                onChange={setLogLevel}
                style={{ width: 110 }}
              >
                <Option value="all">All</Option>
                <Option value="info">Info</Option>
                <Option value="success">Success</Option>
                <Option value="received">Received</Option>
                <Option value="warn">Warning</Option>
                <Option value="error">Error</Option>
              </Select>
              <Badge count={logs.length} overflowCount={999}>
                <Tag style={{ margin: 0 }}>
                  <ThunderboltOutlined /> Logs
                </Tag>
              </Badge>
            </Space>
          }
          actions={[
            <Button
              key="clear"
              type="text"
              size="small"
              icon={<ClearOutlined />}
              onClick={clearLogs}
            >
              Clear
            </Button>,
            <Button
              key="export"
              type="text"
              size="small"
              icon={<ExportOutlined />}
              onClick={exportLogs}
            >
              Export
            </Button>
          ]}
        >
          <div
            ref={logRef}
            style={{
              maxHeight: 260,
              overflowY: 'auto',
              fontFamily: 'monospace',
              fontSize: 12,
              border: '1px solid #f0f0f0',
              padding: 8,
              borderRadius: 4,
              background: '#fafafa'
            }}
          >
            {filteredLogs.length === 0 ? (
              <Empty image={Empty.PRESENTED_IMAGE_SIMPLE} description="No logs" />
            ) : (
              <List
                dataSource={filteredLogs}
                renderItem={(log) => (
                  <List.Item style={{ padding: '4px 0', borderBottom: '1px solid #f5f5f5' }}>
                    <Space align="start" style={{ width: '100%' }}>
                      <Text type="secondary" style={{ minWidth: 70 }}>
                        [{log.ts}]
                      </Text>
                      <Tag
                        color={
                          log.type === 'error'
                            ? 'red'
                            : log.type === 'warn'
                            ? 'orange'
                            : log.type === 'success'
                            ? 'green'
                            : log.type === 'received'
                            ? 'purple'
                            : 'blue'
                        }
                        style={{ marginTop: 0 }}
                      >
                        {log.type.toUpperCase()}
                      </Tag>
                      <Text style={{ whiteSpace: 'pre-wrap', flex: 1 }}>{log.message}</Text>
                      {log.data && (
                        <Button
                          type="link"
                          size="small"
                          icon={<EyeOutlined />}
                          onClick={() =>
                            Modal.info({
                              title: 'Log Payload',
                              content: (
                                <pre style={{ margin: 0 }}>
                                  {typeof log.data === 'string'
                                    ? log.data
                                    : JSON.stringify(log.data, null, 2)}
                                </pre>
                              ),
                              width:600
                            })
                          }
                        />
                      )}
                    </Space>
                  </List.Item>
                )}
              />
            )}
          </div>
        </Card>

        <Modal
          title="JSON Templates"
          open={jsonModalVisible}
          onCancel={() => setJsonModalVisible(false)}
          footer={null}
          width={600}
        >
          <Space direction="vertical" style={{ width: '100%' }} size="middle">
            {[
              {
                name: 'Minimal',
                tpl: {
                  device_id: 'DEVICE123',
                  ssid: 'MyWifi',
                  wifi_password: 'password',
                  network_id: autoNetworkId,
                  key_pair: { publicKey: 'PUBKEY', secretKey: '' }
                }
              },
              {
                name: 'Full Example',
                tpl: {
                  device_id: 'DEVICE123',
                  ssid: 'MyWifi',
                  wifi_password: 'password',
                  network_id: 'mainnet01',
                  key_pair: {
                    publicKey: 'PUBKEY',
                    secretKey: 'SECRET'
                  }
                }
              }
            ].map(({ name, tpl }) => (
              <Card key={name} size="small">
                <Space direction="vertical" style={{ width: '100%' }} size="small">
                  <Space style={{ width: '100%', justifyContent: 'space-between' }}>
                    <Text strong>{name}</Text>
                    <Space>
                      <Button size="small" onClick={() => copyToClipboard(JSON.stringify(tpl, null, 2))}>
                        Copy
                      </Button>
                      <Button
                        size="small"
                        type="primary"
                        onClick={() => {
                          form.setFieldsValue({
                            device_id: tpl.device_id,
                            ssid: tpl.ssid,
                            wifi_password: tpl.wifi_password,
                            network_id: tpl.network_id,
                            publicKey: tpl.key_pair.publicKey,
                            secretKey: tpl.key_pair.secretKey
                          });
                          setJsonModalVisible(false);
                        }}
                      >
                        Use
                      </Button>
                    </Space>
                  </Space>
                  <pre
                    style={{
                      background: '#f5f5f5',
                      margin: 0,
                      padding: 8,
                      fontSize: 12,
                      borderRadius: 4,
                      maxHeight: 200,
                      overflow: 'auto'
                    }}
                  >
                    {JSON.stringify(tpl, null, 2)}
                  </pre>
                </Space>
              </Card>
            ))}
          </Space>
        </Modal>

        <Drawer
          title="Provisioning Settings"
          placement="right"
          open={drawerVisible}
          onClose={() => setDrawerVisible(false)}
          width={screens.xs ? '100%' : 380}
        >
          <Space direction="vertical" style={{ width: '100%' }} size="large">
            <div>
              <Title level={5} style={{ marginBottom: 8 }}>
                Chunk Size
              </Title>
              <InputNumber
                min={20}
                max={512}
                style={{ width: '100%' }}
                value={chunkSize}
                onChange={(v) => setChunkSize(v || DEFAULT_CHUNK_SIZE)}
                addonAfter="bytes"
              />
              <Text type="secondary" style={{ display: 'block', marginTop: 4 }}>
                Payload split threshold (device buffer max {MAX_JSON_SIZE}B, MTU ~180B).
              </Text>
            </div>
            <div>
              <Title level={5} style={{ marginBottom: 8 }}>
                JSON Formatting
              </Title>
              <Switch
                checked={prettyJson}
                onChange={setPrettyJson}
                checkedChildren="Pretty"
                unCheckedChildren="Minified"
              />{' '}
              <Text type="secondary">Outgoing JSON formatting</Text>
            </div>
            <div>
              <Title level={5} style={{ marginBottom: 8 }}>
                Notifications
              </Title>
              <Switch
                checked={notifications}
                onChange={setNotifications}
                checkedChildren="On"
                unCheckedChildren="Off"
              />{' '}
              <Text type="secondary">Desktop popups</Text>
            </div>
            <div>
              <Title level={5} style={{ marginBottom: 8 }}>
                Auto Scroll Logs
              </Title>
              <Switch
                checked={autoScroll}
                onChange={setAutoScroll}
                checkedChildren="On"
                unCheckedChildren="Off"
              />
            </div>
            <Divider />
            <div>
              <Title level={5} style={{ marginBottom: 8 }}>
                UUIDs
              </Title>
              <Descriptions size="small" column={1}>
                <Descriptions.Item label="Service">
                  <Text code copyable>{SERVICE_UUID}</Text>
                </Descriptions.Item>
                <Descriptions.Item label="RX (Write)">
                  <Text code copyable>{RX_CHAR_UUID}</Text>
                </Descriptions.Item>
                <Descriptions.Item label="TX (Notify)">
                  <Text code copyable>{TX_CHAR_UUID}</Text>
                </Descriptions.Item>
              </Descriptions>
            </div>
          </Space>
        </Drawer>
      </Space>
    </div>
  );
};

export default BLEPage;